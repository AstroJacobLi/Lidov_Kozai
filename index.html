<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lidov-Kozai with Tidal Friction</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ICONS ---
        const IconPlay = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );
        const IconPause = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
        );
        const IconRefresh = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        );
        const IconInfo = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="16" x2="12" y2="12"></line>                <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
        );
        const IconFastForward = ({ size = 24, className }) => (
             <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="13 19 22 12 13 5 13 19"></polygon>
                <polygon points="2 19 11 12 2 5 2 19"></polygon>
            </svg>
        );
        const IconWave = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M2 12s3-7 7-7 7 7 7 7 8-7 8-7"></path><path d="M2 12s3 7 7 7 7-7 7-7 8 7 8 7" opacity="0.5"></path>
            </svg>
        );
        const IconStar = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
            </svg>
        );

        const IconChevronDown = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
        );

        const IconGithub = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
        );

        // --- PHYSICS ENGINE ---
        const DEG2RAD = Math.PI / 180;
        const RAD2DEG = 180 / Math.PI;

        const solveKepler = (M, e) => {
            let E = M;
            for (let i = 0; i < 5; i++) {
                E = E - (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
            }
            return E;
        };

        // --- calculate derivatives for dadt ---
        const calculateDerivatives = (e, i, omega, a, tidalStr, stellarType) => {
            const e2 = e * e;
            const sin2w = Math.sin(2 * omega);
            const sin2i = Math.sin(2 * i);
            const sinSqI = Math.sin(i) * Math.sin(i);
            const sinSqW = Math.sin(omega) * Math.sin(omega);
            const sqrtOneMinusE2 = Math.sqrt(1 - e2);

            const epsilon = 0.05; 

            // 1. Kozai-Lidov Terms
            const dedt_kozai = epsilon * (5/2) * e * sqrtOneMinusE2 * sinSqI * sin2w;
            const didt_kozai = -epsilon * (5/2) * (e2 / sqrtOneMinusE2) * Math.sin(2*i) * sin2w;
            
            const term1 = 2 * (1 - e2);
            const term2 = 5 * sinSqW * (e2 - sinSqI);
            const domegadt = (epsilon / sqrtOneMinusE2) * (term1 + term2);
            const dOmegadt = -(epsilon / sqrtOneMinusE2) * Math.cos(i) * (3 + 5 * (e2 - sinSqW));

            // 2. Tidal Friction Terms
            const safeE = Math.min(e, 0.99); 
            const periapseEffect = 1 / (Math.pow(1 - safeE, 3) + 0.01);
            
            const dedt_tide = -tidalStr * e * periapseEffect;

            // --- dadt (orbital decay) ---
            // Formula derived from conservation of Angular Momentum at periapse
            const dadt_tide = dedt_tide * ( (2 * a * safeE) / (1 - safeE*safeE) );

            // 3. Kraft Break
            const stellarDamping = (stellarType === 'cool') ? 0.02 : 0.00;
            const didt_stellar = -stellarDamping * Math.sin(i);

            return { 
                dedt: dedt_kozai + dedt_tide, 
                didt: didt_kozai + didt_stellar,
                domegadt, 
                dOmegadt,
                dadt: dadt_tide // Return shrinking rate
            };
        };

        // --- CHART COMPONENT ---
        const RealtimeChart = ({ data, dataKey, color, label, min, max }) => {
            const width = 100;
            const height = 60;
            
            const getPoints = () => {
                if (data.length < 2) return "";
                const points = data.map((pt, idx) => {
                    const x = (idx / (data.length - 1)) * width;
                    const val = pt[dataKey];
                    // Dynamic Max if not provided (useful for 'a')
                    const effectiveMax = max !== undefined ? max : (Math.max(...data.map(d => d[dataKey])) + 0.5);
                    const normalizedVal = (val - min) / (effectiveMax - min);
                    const y = height - (normalizedVal * height);
                    return `${x},${y}`;
                });
                return points.join(" ");
            };

            const currentVal = data.length > 0 ? data[data.length-1][dataKey] : 0;

            return (
                <div className="flex flex-col bg-slate-900/50 p-2 rounded border border-slate-700">
                    <div className="flex justify-between text-xs mb-1 font-mono text-slate-300">
                        <span style={{ color }}>{label}</span>
                        <span>{currentVal.toFixed(2)}</span>
                    </div>
                    <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-16 overflow-visible">
                        <line x1="0" y1="0" x2={width} y2="0" stroke="#334155" strokeWidth="0.5" />
                        <line x1="0" y1={height} x2={width} y2={height} stroke="#334155" strokeWidth="0.5" />
                        <line x1="0" y1={height/2} x2={width} y2={height/2} stroke="#334155" strokeWidth="0.5" strokeDasharray="2" />
                        <polyline 
                            fill="none" 
                            stroke={color} 
                            strokeWidth="2" 
                            points={getPoints()} 
                            vectorEffect="non-scaling-stroke"
                        />
                    </svg>
                </div>
            );
        };

        // --- MAIN APP ---
        function KozaiApp() {
            const mountRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [simSpeed, setSimSpeed] = useState(0.05);
            
            const [params, setParams] = useState({
                inclination: 65, 
                eccentricity: 0.01,
                omega: 45,
                tidalStrength: 0.00,
                stellarType: 'hot',
                isPhysicsNoteOpen: true
            });
            
            const paramsRef = useRef(params);
            useEffect(() => { paramsRef.current = params; }, [params]);

            // ---  'a' to physical state ---
            const physRef = useRef({
                a: 10,
                e: 0.01,
                i: 65 * DEG2RAD,
                omega: 45 * DEG2RAD,
                Omega: 0,
                time: 0
            });

            const [history, setHistory] = useState([]);
            const historyRef = useRef([]);

            const sceneRef = useRef(null);
            const orbitLineRef = useRef(null);
            const vectorRef = useRef(null);
            const planetMeshRef = useRef(null);
            const starMeshRef = useRef(null); 
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const reqRef = useRef(null);
            const controlsRef = useRef(null);
            
            const resetSimulation = () => {
                physRef.current = {
                    a: 10, // Reset 'a'
                    e: params.eccentricity,
                    i: params.inclination * DEG2RAD,
                    omega: params.omega * DEG2RAD,
                    Omega: 0,
                    time: 0
                };
                setHistory([]);
                historyRef.current = [];
                
                const initialData = {
                    e: params.eccentricity,
                    i: params.inclination,
                    a: 10
                };
                setHistory([initialData]);
                historyRef.current = [initialData];
            };

            const simSpeedRef = useRef(0.05);
            useEffect(() => { simSpeedRef.current = simSpeed; }, [simSpeed]);

            useEffect(() => {
                if (!mountRef.current) return;

                const WIDTH = mountRef.current.clientWidth;
                const HEIGHT = mountRef.current.clientHeight;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0f172a);
                scene.fog = new THREE.FogExp2(0x0f172a, 0.02);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 100);
                camera.position.set(20, 10, 20);
                camera.lookAt(0, 0, 0);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(WIDTH, HEIGHT);
                renderer.setPixelRatio(window.devicePixelRatio);
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controlsRef.current = controls;

                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 2, 100);
                pointLight.position.set(0, 0, 0);
                scene.add(pointLight);

                const starGeo = new THREE.SphereGeometry(1, 32, 32);
                const starMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffdd00, 
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5 
                });
                const star = new THREE.Mesh(starGeo, starMat);
                starMeshRef.current = star; 
                scene.add(star);

                const perturberOrbitGeo = new THREE.RingGeometry(14.8, 15.2, 64);
                const perturberOrbitMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff4444, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const perturberRing = new THREE.Mesh(perturberOrbitGeo, perturberOrbitMat);
                perturberRing.rotation.x = Math.PI / 2;
                scene.add(perturberRing);

                const perturberGeo = new THREE.SphereGeometry(0.8, 16, 16);
                const perturberMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
                const perturber = new THREE.Mesh(perturberGeo, perturberMat);
                perturber.position.set(15, 0, 0);
                scene.add(perturber);

                const orbitPoints = new Float32Array(200 * 3);
                const orbitGeo = new THREE.BufferGeometry();
                orbitGeo.setAttribute('position', new THREE.BufferAttribute(orbitPoints, 3));
                const orbitMat = new THREE.LineBasicMaterial({ color: 0x38bdf8, linewidth: 2 });
                const orbitLine = new THREE.Line(orbitGeo, orbitMat);
                orbitLineRef.current = orbitLine;
                scene.add(orbitLine);

                const planetGeo = new THREE.SphereGeometry(0.4, 16, 16);
                const planetMat = new THREE.MeshStandardMaterial({ color: 0x38bdf8 });
                const planet = new THREE.Mesh(planetGeo, planetMat);
                planetMeshRef.current = planet;
                scene.add(planet);

                const dir = new THREE.Vector3(0, 1, 0);
                const origin = new THREE.Vector3(0, 0, 0);
                const length = 5;
                const hex = 0x34d399;
                const arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
                vectorRef.current = arrowHelper;
                scene.add(arrowHelper);

                const gridHelper = new THREE.GridHelper(40, 40, 0x64748b, 0x334155);
                gridHelper.position.y = -5;
                scene.add(gridHelper);

                // ---  RK4 Step tracks 'a' ---
                const rk4Step = (state, dt, tidalStr, stellarType) => {
                    // Extract 'a'
                    const { e, i, omega, Omega, a } = state;
                    
                    // Pass 'a' to all derivatives
                    const k1 = calculateDerivatives(e, i, omega, a, tidalStr, stellarType);
                    
                    const state2 = {
                        e: e + k1.dedt * dt * 0.5,
                        i: i + k1.didt * dt * 0.5,
                        omega: omega + k1.domegadt * dt * 0.5,
                        a: a + k1.dadt * dt * 0.5
                    };
                    const k2 = calculateDerivatives(state2.e, state2.i, state2.omega, state2.a, tidalStr, stellarType);

                    const state3 = {
                        e: e + k2.dedt * dt * 0.5,
                        i: i + k2.didt * dt * 0.5,
                        omega: omega + k2.domegadt * dt * 0.5,
                        a: a + k2.dadt * dt * 0.5
                    };
                    const k3 = calculateDerivatives(state3.e, state3.i, state3.omega, state3.a, tidalStr, stellarType);

                    const state4 = {
                        e: e + k3.dedt * dt,
                        i: i + k3.didt * dt,
                        omega: omega + k3.domegadt * dt,
                        a: a + k3.dadt * dt
                    };
                    const k4 = calculateDerivatives(state4.e, state4.i, state4.omega, state4.a, tidalStr, stellarType);

                    return {
                        e: e + (dt / 6) * (k1.dedt + 2 * k2.dedt + 2 * k3.dedt + k4.dedt),
                        i: i + (dt / 6) * (k1.didt + 2 * k2.didt + 2 * k3.didt + k4.didt),
                        omega: omega + (dt / 6) * (k1.domegadt + 2 * k2.domegadt + 2 * k3.domegadt + k4.domegadt),
                        Omega: Omega + (dt / 6) * (k1.dOmegadt + 2 * k2.dOmegadt + 2 * k3.dOmegadt + k4.dOmegadt),
                        a: a + (dt / 6) * (k1.dadt + 2 * k2.dadt + 2 * k3.dadt + k4.dadt)
                    };
                };

                const animate = () => {
                    reqRef.current = requestAnimationFrame(animate);

                    if (isPlaying) {
                        const p = physRef.current;
                        const totalTimeStep = simSpeedRef.current;
                        const physicsDt = 0.005; 
                        let timeAccumulator = 0;

                        const currentTide = paramsRef.current.tidalStrength;
                        const currentStar = paramsRef.current.stellarType;

                        while (timeAccumulator < totalTimeStep) {
                            const step = Math.min(physicsDt, totalTimeStep - timeAccumulator);
                            
                            const nextState = rk4Step(p, step, currentTide, currentStar);
                            
                            p.e = nextState.e;
                            p.i = nextState.i;
                            p.omega = nextState.omega;
                            p.Omega = nextState.Omega;
                            p.a = nextState.a; // Update 'a'
                            p.time += step;
                            
                            timeAccumulator += step;

                            if (p.e < 0.001) p.e = 0.001;
                            if (p.e > 0.99) p.e = 0.99;
                            if (p.a < 0.5) p.a = 0.5; // Prevent singularity
                        }

                        if (Math.floor(p.time * 10) % 5 === 0) {
                            const newData = {
                                e: p.e,
                                i: p.i * RAD2DEG,
                                a: p.a
                            };
                            historyRef.current.push(newData);
                            if (historyRef.current.length > 200) historyRef.current.shift();
                            setHistory([...historyRef.current]);
                        }
                    }

                    updateOrbitGeometry();
                    controlsRef.current.update();
                    renderer.render(scene, camera);
                };

                const updateOrbitGeometry = () => {
                    const p = physRef.current;
                    const positions = orbitLine.geometry.attributes.position.array;
                    
                    // ---  Use dynamic 'a' for visuals ---
                    const a = p.a; 

                    if (starMeshRef.current) {
                        if (paramsRef.current.stellarType === 'hot') {
                            starMeshRef.current.material.color.setHex(0xaaddff); 
                            starMeshRef.current.material.emissive.setHex(0x0044aa);
                        } else {
                            starMeshRef.current.material.color.setHex(0xffdd00); 
                            starMeshRef.current.material.emissive.setHex(0xffaa00);
                        }
                    }

                    const nx = Math.sin(p.i) * Math.sin(p.Omega);
                    const ny = Math.cos(p.i);
                    const nz = -Math.sin(p.i) * Math.cos(p.Omega);
                    
                    vectorRef.current.setDirection(new THREE.Vector3(nx, ny, nz).normalize());
                    const L_mag = Math.sqrt(1 - p.e * p.e);
                    vectorRef.current.setLength(5 * L_mag);

                    for (let j = 0; j < 200; j++) {
                        const theta = (j / 199) * 2 * Math.PI;
                        const r = (a * (1 - p.e * p.e)) / (1 + p.e * Math.cos(theta));
                        
                        const wf = theta + p.omega;
                        const X = r * (Math.cos(p.Omega) * Math.cos(wf) - Math.sin(p.Omega) * Math.sin(wf) * Math.cos(p.i));
                        const Y = r * (Math.sin(p.Omega) * Math.cos(wf) + Math.cos(p.Omega) * Math.sin(wf) * Math.cos(p.i));
                        const Z = r * (Math.sin(p.i) * Math.sin(wf));

                        positions[j * 3] = X;
                        positions[j * 3 + 1] = Z; 
                        positions[j * 3 + 2] = Y; 
                    }
                    orbitLine.geometry.attributes.position.needsUpdate = true;

                    const M = (Date.now() * 0.008) % (2 * Math.PI);
                    
                    const E = solveKepler(M, p.e);
                    
                    const P = a * (Math.cos(E) - p.e);
                    const Q = a * Math.sqrt(1 - p.e*p.e) * Math.sin(E);
                    
                    const cosOm = Math.cos(p.Omega); const sinOm = Math.sin(p.Omega);
                    const cosw = Math.cos(p.omega); const sinw = Math.sin(p.omega);
                    const cosi = Math.cos(p.i); const sini = Math.sin(p.i);

                    const pX = P * (cosOm*cosw - sinOm*sinw*cosi) - Q * (cosOm*sinw + sinOm*cosw*cosi);
                    const pY = P * (sinOm*cosw + cosOm*sinw*cosi) - Q * (sinOm*sinw - cosOm*cosw*cosi);
                    const pZ = P * (sinw*sini) + Q * (cosw*sini);
                    
                    planetMeshRef.current.position.set(pX, pZ, pY);
                    
                    if (paramsRef.current.tidalStrength > 0.005) {
                         planetMeshRef.current.material.emissive.setHex(0xffffff);
                         planetMeshRef.current.material.emissiveIntensity = p.e; 
                    } else {
                         planetMeshRef.current.material.emissive.setHex(0x000000);
                    }
                };

                animate();

                const handleResize = () => {
                    if (!mountRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    renderer.setSize(w, h);
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    cancelAnimationFrame(reqRef.current);
                    window.removeEventListener('resize', handleResize);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    renderer.dispose();
                    if(controlsRef.current) controlsRef.current.dispose();
                };
            }, [isPlaying]); 

            useEffect(() => {
                resetSimulation();
            }, [params.inclination, params.eccentricity, params.omega]);

            const [sidebarWidth, setSidebarWidth] = useState(320);
            const [isResizing, setIsResizing] = useState(false);
            const [isDesktop, setIsDesktop] = useState(window.innerWidth >= 768);

            useEffect(() => {
                const handleResize = () => setIsDesktop(window.innerWidth >= 768);
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const startResizing = useCallback(() => setIsResizing(true), []);
            const stopResizing = useCallback(() => setIsResizing(false), []);
            const resize = useCallback((mouseMoveEvent) => {
                if (isResizing) {
                    const newWidth = mouseMoveEvent.clientX;
                    if (newWidth > 200 && newWidth < 600) {
                        setSidebarWidth(newWidth);
                    }
                }
            }, [isResizing]);

            useEffect(() => {
                window.addEventListener("mousemove", resize);
                window.addEventListener("mouseup", stopResizing);
                return () => {
                    window.removeEventListener("mousemove", resize);
                    window.removeEventListener("mouseup", stopResizing);
                };
            }, [resize, stopResizing]);

            return (
                <div className="w-full h-screen bg-slate-950 text-slate-100 font-sans flex flex-col-reverse md:flex-row overflow-hidden">
                    
                    <div 
                        className="w-full bg-slate-900 border-r border-slate-800 flex flex-col h-1/2 md:h-full z-10 shadow-xl flex-shrink-0"
                        style={isDesktop ? { width: sidebarWidth } : {}}
                    >
                        <div className="p-4 border-b border-slate-800 bg-slate-800/50">
                            <h1 className="text-lg font-bold bg-gradient-to-r from-sky-400 to-indigo-400 bg-clip-text text-transparent">
                                Lidov-Kozai Mechanism
                            </h1>
                            <p className="text-xs text-slate-400 mt-1">
                                w/ Tidal Friction Simulator
                            </p>
                        </div>

                        <div className="flex-1 overflow-y-auto p-4 space-y-6">
                            
                            <div className="space-y-4">
                                <label className="block">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-slate-300">Initial Inclination (i₀)</span>
                                        <span className="font-mono text-sky-400">{params.inclination}°</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0" max="90" step="0.1"
                                        value={params.inclination}
                                        onChange={(e) => setParams(p => ({...p, inclination: parseFloat(e.target.value)}))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-sky-500"
                                    />
                                    <div className="text-xs text-slate-500 mt-1">
                                        Critical Angle: ~39.2°
                                    </div>
                                </label>

                                <label className="block">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-slate-300">Initial Eccentricity (e₀)</span>
                                        <span className="font-mono text-emerald-400">{params.eccentricity}</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0.01" max="0.8" step="0.01"
                                        value={params.eccentricity}
                                        onChange={(e) => setParams(p => ({...p, eccentricity: parseFloat(e.target.value)}))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-emerald-500"
                                    />
                                </label>

                                <label className="block pt-4 border-t border-slate-700">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-pink-300 flex items-center font-bold">
                                            <IconWave size={14} className="mr-2"/> Tidal Strength
                                        </span>
                                        <span className="font-mono text-pink-400">{params.tidalStrength > 0 ? (params.tidalStrength * 1000).toFixed(1) : "OFF"}</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0" max="0.02" step="0.001"
                                        value={params.tidalStrength}
                                        onChange={(e) => setParams(p => ({...p, tidalStrength: parseFloat(e.target.value)}))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-pink-500"
                                    />
                                    <div className="text-xs text-slate-400 mt-2 leading-tight">
                                        Simulates energy loss at periapsis. Damps eccentricity.
                                    </div>
                                </label>

                                <div className="block pt-2">
                                    <div className="flex justify-between text-sm mb-2">
                                        <span className="text-yellow-300 font-bold flex items-center">
                                            <IconStar size={14} className="mr-2"/> Host Star Type
                                        </span>
                                    </div>
                                    <div className="flex bg-slate-800 rounded p-1">
                                        <button 
                                            onClick={() => setParams(p => ({...p, stellarType: 'hot'}))}
                                            className={`flex-1 py-1 text-xs rounded font-semibold transition-colors ${params.stellarType === 'hot' ? 'bg-sky-600 text-white' : 'text-slate-400 hover:text-white'}`}
                                        >
                                            HOT (Radiative)
                                        </button>
                                        <button 
                                            onClick={() => setParams(p => ({...p, stellarType: 'cool'}))}
                                            className={`flex-1 py-1 text-xs rounded font-semibold transition-colors ${params.stellarType === 'cool' ? 'bg-yellow-600 text-white' : 'text-slate-400 hover:text-white'}`}
                                        >
                                            COOL (Convective)
                                        </button>
                                    </div>
                                    <div className="text-xs text-slate-400 mt-2 leading-tight">
                                        <strong>Cool:</strong> Efficient alignment. Inclination decays.<br/>
                                        <strong>Hot:</strong> Inefficient. Misalignment survives.
                                    </div>
                                </div>

                                <label className="block pt-2 border-t border-slate-700">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-slate-300 flex items-center">
                                            <IconFastForward size={14} className="mr-1"/> Sim Speed
                                        </span>
                                        <span className="font-mono text-amber-400">{simSpeed.toFixed(2)}</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0.01" max="0.5" step="0.01"
                                        value={simSpeed}
                                        onChange={(e) => setSimSpeed(parseFloat(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                    />
                                </label>
                            </div>

                            <div className="grid grid-cols-2 gap-2">
                                <button 
                                    onClick={() => setIsPlaying(!isPlaying)}
                                    className={`flex items-center justify-center p-2 rounded font-semibold transition-colors ${
                                        isPlaying 
                                        ? 'bg-amber-500/20 text-amber-400 hover:bg-amber-500/30' 
                                        : 'bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30'
                                    }`}
                                >
                                    {isPlaying 
                                        ? <><IconPause className="mr-2"/> Pause</> 
                                        : <><IconPlay className="mr-2"/> Start</>
                                    }
                                </button>
                                <button 
                                    onClick={resetSimulation}
                                    className="flex items-center justify-center p-2 rounded bg-slate-700 hover:bg-slate-600 text-slate-200 transition-colors"
                                >
                                    <IconRefresh className="mr-2"/> Reset
                                </button>
                            </div>

                            <div className="bg-indigo-900/20 border border-indigo-500/30 rounded-lg text-sm text-indigo-200 overflow-hidden">
                                <button 
                                    onClick={() => setParams(p => ({...p, isPhysicsNoteOpen: !p.isPhysicsNoteOpen}))}
                                    className="w-full flex items-center justify-between p-3 font-semibold hover:bg-indigo-500/10 transition-colors"
                                >
                                    <div className="flex items-center">
                                        <IconInfo className="mr-2"/> Physics Note
                                    </div>
                                    <IconChevronDown 
                                        size={16} 
                                        className={`transition-transform duration-200 ${params.isPhysicsNoteOpen ? 'rotate-180' : ''}`}
                                    />
                                </button>
                                
                                {params.isPhysicsNoteOpen && (
                                    <div className="p-3 pt-0 border-t border-indigo-500/10">
                                        <div className="text-xs opacity-80 mb-2 mt-2">
                                            With <strong>Tides OFF</strong>,  <div className="my-2 font-mono text-center bg-black/20 p-2 rounded text-xs">L_z = √(1 - e²) cos(i) ≈ const</div> is conserved and the orbit oscillates forever.
                                        </div>
                                        <div className="text-xs opacity-80">
                                            With <strong>Tides ON</strong>, energy is lost at periapsis (high e). This circularizes the orbit.
                                        </div>
                                    </div>
                                )}
                            </div>
                        

                        <div className="pt-4 border-t border-slate-800 space-y-2">
                            <h3 className="text-xs font-bold text-slate-500 uppercase">Live Data</h3>
                            <RealtimeChart 
                                data={history} 
                                dataKey="e" 
                                color="#34d399" 
                                label="Eccentricity (e)"
                                min={0} max={1}
                            />
                            {/* ---  'a' Chart --- */}
                            <RealtimeChart 
                                data={history} 
                                dataKey="a" 
                                color="#f472b6" 
                                label="Semi-Major Axis (a)"
                                min={0} max={10}
                            />
                            <RealtimeChart 
                                data={history} 
                                dataKey="i" 
                                color="#38bdf8" 
                                label="Inclination (deg)"
                                min={0} max={90}
                            />
                            </div>
                        </div>

                        <div className="p-4 border-t border-slate-800 bg-slate-900 text-xs text-slate-500 flex justify-between items-center">
                            <span>By Jiaxuan Li & Chris Wang with the help of Gemini 3 pro.</span>
                            <a href="https://github.com/AstroJacobLi/Lidov_Kozai" target="_blank" rel="noopener noreferrer" className="text-slate-400 hover:text-white transition-colors">
                                <IconGithub size={16} />
                            </a>
                        </div>
                    </div>

                    {isDesktop && (
                        <div
                            className="w-1 bg-slate-800 hover:bg-sky-500 cursor-col-resize transition-colors z-20 flex-shrink-0"
                            onMouseDown={startResizing}
                        />
                    )}

                    <div className="flex-1 relative bg-black">
                        <div ref={mountRef} className="w-full h-full cursor-move"></div>
                        
                        <div className="absolute top-4 left-4 pointer-events-none space-y-1 select-none">
                            <div className="flex items-center space-x-2">
                                <div className="w-3 h-3 rounded-full bg-yellow-400 shadow-[0_0_10px_rgba(250,204,21,0.5)]"></div>
                                <span className="text-xs text-yellow-100 font-mono">Inner Binary (M₁)</span>
                            </div>
                            <div className="flex items-center space-x-2">
                                <div className="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_rgba(239,68,68,0.5)]"></div>
                                <span className="text-xs text-red-200 font-mono">Perturber (M₃)</span>
                            </div>
                            <div className="flex items-center space-x-2">
                                <div className="w-8 h-0.5 bg-sky-400"></div>
                                <span className="text-xs text-sky-200 font-mono">Orbit Path</span>
                            </div>
                            <div className="flex items-center space-x-2">
                                <span className="text-2xl text-emerald-400 font-bold">↑</span>
                                <span className="text-xs text-emerald-200 font-mono">Angular Momentum</span>
                            </div>
                        </div>

                        <div className="absolute bottom-4 right-4 text-right pointer-events-none">
                            <h3 className="text-2xl font-black text-slate-800 select-none">3D VIEW</h3>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<KozaiApp />);
    </script>
</body>
</html>
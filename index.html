<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lidov-Kozai with Tidal Friction</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONS ---
        const IconPlay = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );
        const IconPause = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
        );
        const IconRefresh = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        );
        const IconInfo = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="16" x2="12" y2="12"></line>                <line x1="12" y1="8" x2="12.01" y2="8"></line>
            </svg>
        );
        const IconFastForward = ({ size = 24, className }) => (
             <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="13 19 22 12 13 5 13 19"></polygon>
                <polygon points="2 19 11 12 2 5 2 19"></polygon>
            </svg>
        );
        const IconWave = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M2 12s3-7 7-7 7 7 7 7 8-7 8-7"></path>
                <path d="M2 12s3 7 7 7 7-7 7-7 8 7 8 7" opacity="0.5"></path>
            </svg>
        );

        const IconGithub = ({ size = 24, className }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
        );

        // --- PHYSICS ENGINE ---
        const DEG2RAD = Math.PI / 180;
        const RAD2DEG = 180 / Math.PI;

        // Calculates derivatives for RK4 Integration
        // `tidalStr` parameter
        const calculateDerivatives = (e, i, omega, tidalStr) => {
            const e2 = e * e;
            const sin2w = Math.sin(2 * omega);
            const sin2i = Math.sin(2 * i);
            const sinSqI = Math.sin(i) * Math.sin(i);
            const sinSqW = Math.sin(omega) * Math.sin(omega);
            const sqrtOneMinusE2 = Math.sqrt(1 - e2);

            const epsilon = 0.05; // Strength of Quadrupole perturbation

            // 1. Kozai-Lidov Terms (Conservative)
            const dedt_kozai = epsilon * (5/2) * e * sqrtOneMinusE2 * sinSqI * sin2w;
            const didt_kozai = -epsilon * (5/2) * (e2 / sqrtOneMinusE2) * Math.sin(2*i) * sin2w;
            
            const term1 = 2 * (1 - e2);
            const term2 = 5 * sinSqW * (e2 - sinSqI);
            const domegadt = (epsilon / sqrtOneMinusE2) * (term1 + term2);
            const dOmegadt = -(epsilon / sqrtOneMinusE2) * Math.cos(i) * (3 + 5 * (e2 - sinSqW));

            // 2. Tidal Friction Terms (Dissipative)
            // Model: Friction increases drastically as planet gets closer (high e)
            // We model this as a drag on eccentricity.
            // Formula approximation: de/dt_tide ~ - e / (1-e)^N 
            // We use (1-e)^3 to make it very sharp near e=1
            const safeE = Math.min(e, 0.99); // Prevent division by zero
            const periapseEffect = 1 / (Math.pow(1 - safeE, 3) + 0.01);
            
            // tidalStr is the slider value (0.0 to 0.1)
            const dedt_tide = -tidalStr * e * periapseEffect;

            return { 
                dedt: dedt_kozai + dedt_tide, 
                didt: didt_kozai, 
                domegadt, 
                dOmegadt 
            };
        };

        // --- CHART COMPONENT ---
        const RealtimeChart = ({ data, dataKey, color, label, min, max }) => {
            const width = 100;
            const height = 60;
            
            const getPoints = () => {
                if (data.length < 2) return "";
                const points = data.map((pt, idx) => {
                    const x = (idx / (data.length - 1)) * width;
                    const val = pt[dataKey];
                    const normalizedVal = (val - min) / (max - min);
                    const y = height - (normalizedVal * height);
                    return `${x},${y}`;
                });
                return points.join(" ");
            };

            return (
                <div className="flex flex-col bg-slate-900/50 p-2 rounded border border-slate-700">
                    <div className="flex justify-between text-xs mb-1 font-mono text-slate-300">
                        <span style={{ color }}>{label}</span>
                        <span>{data.length > 0 ? data[data.length-1][dataKey].toFixed(2) : 0}</span>
                    </div>
                    <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-16 overflow-visible">
                        <line x1="0" y1="0" x2={width} y2="0" stroke="#334155" strokeWidth="0.5" />
                        <line x1="0" y1={height} x2={width} y2={height} stroke="#334155" strokeWidth="0.5" />
                        <line x1="0" y1={height/2} x2={width} y2={height/2} stroke="#334155" strokeWidth="0.5" strokeDasharray="2" />
                        <polyline 
                            fill="none" 
                            stroke={color} 
                            strokeWidth="2" 
                            points={getPoints()} 
                            vectorEffect="non-scaling-stroke"
                        />
                    </svg>
                </div>
            );
        };

        // --- MAIN APP ---
        function KozaiApp() {
            const mountRef = useRef(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [simSpeed, setSimSpeed] = useState(0.05);
            
            // Params
            const [params, setParams] = useState({
                inclination: 65, // High initial inclination for strong Kozai
                eccentricity: 0.01,
                omega: 45,
                tidalStrength: 0.00
            });
            
            // Use ref for params to access in animation loop without stale closures
            const paramsRef = useRef(params);
            useEffect(() => { paramsRef.current = params; }, [params]);

            // Physics State
            const physRef = useRef({
                e: 0.01,
                i: 65 * DEG2RAD,
                omega: 45 * DEG2RAD,
                Omega: 0,
                time: 0
            });

            const [history, setHistory] = useState([]);
            const historyRef = useRef([]);

            // Three.js Refs
            const sceneRef = useRef(null);
            const orbitLineRef = useRef(null);
            const vectorRef = useRef(null);
            const planetMeshRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const reqRef = useRef(null);
            const controlsRef = useRef(null);
            
            const resetSimulation = () => {
                physRef.current = {
                    e: params.eccentricity,
                    i: params.inclination * DEG2RAD,
                    omega: params.omega * DEG2RAD,
                    Omega: 0,
                    time: 0
                };
                setHistory([]);
                historyRef.current = [];
                
                const initialData = {
                    e: params.eccentricity,
                    i: params.inclination,
                    lz: Math.sqrt(1 - params.eccentricity**2) * Math.cos(params.inclination * DEG2RAD)
                };
                setHistory([initialData]);
                historyRef.current = [initialData];
            };

            const simSpeedRef = useRef(0.05);
            useEffect(() => { simSpeedRef.current = simSpeed; }, [simSpeed]);

            useEffect(() => {
                if (!mountRef.current) return;

                const WIDTH = mountRef.current.clientWidth;
                const HEIGHT = mountRef.current.clientHeight;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0f172a);
                scene.fog = new THREE.FogExp2(0x0f172a, 0.02);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 100);
                camera.position.set(20, 10, 20);
                camera.lookAt(0, 0, 0);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(WIDTH, HEIGHT);
                renderer.setPixelRatio(window.devicePixelRatio);
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Controls
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controlsRef.current = controls;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 2);
                scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 2, 100);
                pointLight.position.set(0, 0, 0);
                scene.add(pointLight);

                // Star
                const starGeo = new THREE.SphereGeometry(1, 32, 32);
                const starMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffdd00, 
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5 
                });
                const star = new THREE.Mesh(starGeo, starMat);
                scene.add(star);

                // Perturber Ring
                const perturberOrbitGeo = new THREE.RingGeometry(14.8, 15.2, 64);
                const perturberOrbitMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff4444, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const perturberRing = new THREE.Mesh(perturberOrbitGeo, perturberOrbitMat);
                perturberRing.rotation.x = Math.PI / 2;
                scene.add(perturberRing);

                // Perturber Sphere
                const perturberGeo = new THREE.SphereGeometry(0.8, 16, 16);
                const perturberMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
                const perturber = new THREE.Mesh(perturberGeo, perturberMat);
                perturber.position.set(15, 0, 0);
                scene.add(perturber);

                // Orbit Line
                const orbitPoints = new Float32Array(200 * 3);
                const orbitGeo = new THREE.BufferGeometry();
                orbitGeo.setAttribute('position', new THREE.BufferAttribute(orbitPoints, 3));
                const orbitMat = new THREE.LineBasicMaterial({ color: 0x38bdf8, linewidth: 2 });
                const orbitLine = new THREE.Line(orbitGeo, orbitMat);
                orbitLineRef.current = orbitLine;
                scene.add(orbitLine);

                // Planet
                const planetGeo = new THREE.SphereGeometry(0.4, 16, 16);
                const planetMat = new THREE.MeshStandardMaterial({ color: 0x38bdf8 });
                const planet = new THREE.Mesh(planetGeo, planetMat);
                planetMeshRef.current = planet;
                scene.add(planet);

                // Lz Vector
                const dir = new THREE.Vector3(0, 1, 0);
                const origin = new THREE.Vector3(0, 0, 0);
                const length = 5;
                const hex = 0x34d399;
                const arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
                vectorRef.current = arrowHelper;
                scene.add(arrowHelper);

                // Grid
                const gridHelper = new THREE.GridHelper(40, 40, 0x64748b, 0x334155);
                gridHelper.position.y = -5;
                scene.add(gridHelper);

                // RK4 Integrator Step
                const rk4Step = (state, dt, tidalStr) => {
                    const { e, i, omega, Omega } = state;
                    
                    // K1
                    const k1 = calculateDerivatives(e, i, omega, tidalStr);
                    
                    // K2
                    const state2 = {
                        e: e + k1.dedt * dt * 0.5,
                        i: i + k1.didt * dt * 0.5,
                        omega: omega + k1.domegadt * dt * 0.5
                    };
                    const k2 = calculateDerivatives(state2.e, state2.i, state2.omega, tidalStr);

                    // K3
                    const state3 = {
                        e: e + k2.dedt * dt * 0.5,
                        i: i + k2.didt * dt * 0.5,
                        omega: omega + k2.domegadt * dt * 0.5
                    };
                    const k3 = calculateDerivatives(state3.e, state3.i, state3.omega, tidalStr);

                    // K4
                    const state4 = {
                        e: e + k3.dedt * dt,
                        i: i + k3.didt * dt,
                        omega: omega + k3.domegadt * dt
                    };
                    const k4 = calculateDerivatives(state4.e, state4.i, state4.omega, tidalStr);

                    return {
                        e: e + (dt / 6) * (k1.dedt + 2 * k2.dedt + 2 * k3.dedt + k4.dedt),
                        i: i + (dt / 6) * (k1.didt + 2 * k2.didt + 2 * k3.didt + k4.didt),
                        omega: omega + (dt / 6) * (k1.domegadt + 2 * k2.domegadt + 2 * k3.domegadt + k4.domegadt),
                        Omega: Omega + (dt / 6) * (k1.dOmegadt + 2 * k2.dOmegadt + 2 * k3.dOmegadt + k4.dOmegadt)
                    };
                };

                // Loop
                const animate = () => {
                    reqRef.current = requestAnimationFrame(animate);

                    if (isPlaying) {
                        const p = physRef.current;
                        const totalTimeStep = simSpeedRef.current;
                        const physicsDt = 0.005; 
                        let timeAccumulator = 0;

                        // Grab current tidal strength from ref/state
                        const currentTide = paramsRef.current.tidalStrength;

                        while (timeAccumulator < totalTimeStep) {
                            const step = Math.min(physicsDt, totalTimeStep - timeAccumulator);
                            
                            // Pass tidal strength to integrator
                            const nextState = rk4Step(p, step, currentTide);
                            
                            p.e = nextState.e;
                            p.i = nextState.i;
                            p.omega = nextState.omega;
                            p.Omega = nextState.Omega;
                            p.time += step;
                            
                            timeAccumulator += step;

                            // Safety clamps
                            if (p.e < 0.001) p.e = 0.001;
                            if (p.e > 0.99) p.e = 0.99;
                        }

                        // Chart updates
                        if (Math.floor(p.time * 10) % 5 === 0) {
                            const newData = {
                                e: p.e,
                                i: p.i * RAD2DEG,
                                lz: Math.sqrt(1 - p.e**2) * Math.cos(p.i)
                            };
                            historyRef.current.push(newData);
                            if (historyRef.current.length > 200) historyRef.current.shift();
                            setHistory([...historyRef.current]);
                        }
                    }

                    updateOrbitGeometry();
                    controlsRef.current.update();
                    renderer.render(scene, camera);
                };

                const updateOrbitGeometry = () => {
                    const p = physRef.current;
                    const positions = orbitLine.geometry.attributes.position.array;
                    
                    // Fixed semi-major axis for visualization simplicity 
                    const a = 8; 

                    // Update Lz Vector
                    const nx = Math.sin(p.i) * Math.sin(p.Omega);
                    const ny = Math.cos(p.i);
                    const nz = -Math.sin(p.i) * Math.cos(p.Omega);
                    
                    vectorRef.current.setDirection(new THREE.Vector3(nx, ny, nz).normalize());
                    const L_mag = Math.sqrt(1 - p.e * p.e);
                    vectorRef.current.setLength(5 * L_mag);

                    // Re-calculate Ellipse Points
                    for (let j = 0; j < 200; j++) {
                        const theta = (j / 199) * 2 * Math.PI;
                        const r = (a * (1 - p.e * p.e)) / (1 + p.e * Math.cos(theta));
                        
                        const wf = theta + p.omega;
                        const X = r * (Math.cos(p.Omega) * Math.cos(wf) - Math.sin(p.Omega) * Math.sin(wf) * Math.cos(p.i));
                        const Y = r * (Math.sin(p.Omega) * Math.cos(wf) + Math.cos(p.Omega) * Math.sin(wf) * Math.cos(p.i));
                        const Z = r * (Math.sin(p.i) * Math.sin(wf));

                        positions[j * 3] = X;
                        positions[j * 3 + 1] = Z; 
                        positions[j * 3 + 2] = Y; 
                    }
                    orbitLine.geometry.attributes.position.needsUpdate = true;

                    // Update Planet Position
                    const vizTheta = (Date.now() * 0.008) % (2 * Math.PI);
                    const r_viz = (a * (1 - p.e * p.e)) / (1 + p.e * Math.cos(vizTheta));
                    const wf_viz = vizTheta + p.omega;
                    const pX = r_viz * (Math.cos(p.Omega) * Math.cos(wf_viz) - Math.sin(p.Omega) * Math.sin(wf_viz) * Math.cos(p.i));
                    const pY = r_viz * (Math.sin(p.Omega) * Math.cos(wf_viz) + Math.cos(p.Omega) * Math.sin(wf_viz) * Math.cos(p.i));
                    const pZ = r_viz * (Math.sin(p.i) * Math.sin(wf_viz));
                    
                    planetMeshRef.current.position.set(pX, pZ, pY);
                    
                    // Visual cue for high tide
                    if (paramsRef.current.tidalStrength > 0.005) {
                         planetMeshRef.current.material.emissive.setHex(0xffffff);
                         planetMeshRef.current.material.emissiveIntensity = p.e; // Glow more at high e
                    } else {
                         planetMeshRef.current.material.emissive.setHex(0x000000);
                    }
                };

                animate();

                const handleResize = () => {
                    if (!mountRef.current) return;
                    const w = mountRef.current.clientWidth;
                    const h = mountRef.current.clientHeight;
                    renderer.setSize(w, h);
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    cancelAnimationFrame(reqRef.current);
                    window.removeEventListener('resize', handleResize);
                    if (mountRef.current && renderer.domElement) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    renderer.dispose();
                    if(controlsRef.current) controlsRef.current.dispose();
                    starGeo.dispose(); starMat.dispose();
                };
            }, [isPlaying]); // Re-init on simple play toggle not needed strictly but kept for safety

            // Only reset physics if inclination/e/omega sliders change, NOT tidal slider
            // turn on tides mid-simulation
            useEffect(() => {
                resetSimulation();
            }, [params.inclination, params.eccentricity, params.omega]);

            return (
                <div className="w-full h-screen bg-slate-950 text-slate-100 font-sans flex flex-col-reverse md:flex-row overflow-hidden">
                    
                    {/* SIDEBAR CONTROLS */}
                    <div className="w-full md:w-80 bg-slate-900 border-r border-slate-800 flex flex-col h-1/2 md:h-full z-10 shadow-xl">
                        <div className="p-4 border-b border-slate-800 bg-slate-800/50">
                            <h1 className="text-lg font-bold bg-gradient-to-r from-sky-400 to-indigo-400 bg-clip-text text-transparent">
                                Lidov-Kozai Mechanism
                            </h1>
                            <p className="text-xs text-slate-400 mt-1">
                                w/ Tidal Friction Simulator
                            </p>
                        </div>

                        <div className="flex-1 overflow-y-auto p-4 space-y-6">
                            
                            {/* Controls */}
                            <div className="space-y-4">
                                <label className="block">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-slate-300">Initial Inclination (i₀)</span>
                                        <span className="font-mono text-sky-400">{params.inclination}°</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0" max="90" step="0.1"
                                        value={params.inclination}
                                        onChange={(e) => setParams(p => ({...p, inclination: parseFloat(e.target.value)}))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-sky-500"
                                    />
                                    <div className="text-xs text-slate-500 mt-1">
                                        Critical Angle: ~39.2°
                                    </div>
                                </label>

                                <label className="block">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-slate-300">Initial Eccentricity (e₀)</span>
                                        <span className="font-mono text-emerald-400">{params.eccentricity}</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0.01" max="0.8" step="0.01"
                                        value={params.eccentricity}
                                        onChange={(e) => setParams(p => ({...p, eccentricity: parseFloat(e.target.value)}))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-emerald-500"
                                    />
                                </label>

                                {/*  Tidal Slider */}
                                <label className="block pt-4 border-t border-slate-700">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-pink-300 flex items-center font-bold">
                                            <IconWave size={14} className="mr-2"/> Tidal Strength
                                        </span>
                                        <span className="font-mono text-pink-400">{params.tidalStrength > 0 ? (params.tidalStrength * 1000).toFixed(1) : "OFF"}</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0" max="0.02" step="0.001"
                                        value={params.tidalStrength}
                                        onChange={(e) => setParams(p => ({...p, tidalStrength: parseFloat(e.target.value)}))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-pink-500"
                                    />
                                    <div className="text-xs text-slate-400 mt-2 leading-tight">
                                        Simulates energy loss at periapsis. Damps eccentricity and kills Kozai cycles.
                                    </div>
                                </label>

                                <label className="block pt-2 border-t border-slate-700">
                                    <div className="flex justify-between text-sm mb-1">
                                        <span className="text-slate-300 flex items-center">
                                            <IconFastForward size={14} className="mr-1"/> Sim Speed
                                        </span>
                                        <span className="font-mono text-amber-400">{simSpeed.toFixed(2)}</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0.01" max="0.5" step="0.01"
                                        value={simSpeed}
                                        onChange={(e) => setSimSpeed(parseFloat(e.target.value))}
                                        className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                    />
                                </label>
                            </div>

                            {/* Buttons */}
                            <div className="grid grid-cols-2 gap-2">
                                <button 
                                    onClick={() => setIsPlaying(!isPlaying)}
                                    className={`flex items-center justify-center p-2 rounded font-semibold transition-colors ${
                                        isPlaying 
                                        ? 'bg-amber-500/20 text-amber-400 hover:bg-amber-500/30' 
                                        : 'bg-emerald-500/20 text-emerald-400 hover:bg-emerald-500/30'
                                    }`}
                                >
                                    {isPlaying 
                                        ? <><IconPause className="mr-2"/> Pause</> 
                                        : <><IconPlay className="mr-2"/> Start</>
                                    }
                                </button>
                                <button 
                                    onClick={resetSimulation}
                                    className="flex items-center justify-center p-2 rounded bg-slate-700 hover:bg-slate-600 text-slate-200 transition-colors"
                                >
                                    <IconRefresh className="mr-2"/> Reset
                                </button>
                            </div>

                            {/* Info */}
                            <div className="bg-indigo-900/20 border border-indigo-500/30 p-3 rounded-lg text-sm text-indigo-200">
                                <div className="flex items-center mb-2 font-semibold">
                                    <IconInfo className="mr-2"/> Physics Note
                                </div>
                                <div className="text-xs opacity-80 mb-2">
                                    With <strong>Tides OFF</strong>,  <div className="my-2 font-mono text-center bg-black/20 p-2 rounded text-xs">L_z = √(1 - e²) cos(i) ≈ const</div> is conserved and the orbit oscillates forever.
                                </div>
                                <div className="text-xs opacity-80">
                                    With <strong>Tides ON</strong>, energy is lost at periapsis (high e). This circularizes the orbit and eventually stops the Kozai cycles.
                                </div>
                            </div>
                        

                        {/* Graphs */}
                        <div className="pt-4 border-t border-slate-800 space-y-2">
                            <h3 className="text-xs font-bold text-slate-500 uppercase">Live Data</h3>
                            <RealtimeChart 
                                data={history} 
                                dataKey="e" 
                                color="#34d399" 
                                label="Eccentricity (e)"
                                min={0} max={1}
                            />
                            <RealtimeChart 
                                data={history} 
                                dataKey="i" 
                                color="#38bdf8" 
                                label="Inclination (deg)"
                                min={0} max={90}
                            />
                            </div>
                        </div>

                        {/* Footer */}
                        <div className="p-4 border-t border-slate-800 bg-slate-900 text-xs text-slate-500 flex justify-between items-center">
                            <span>By Jiaxuan Li & Chris Wang with the help of Gemini 3 pro.</span>
                            <a href="https://github.com/AstroJacobLi/Lidov_Kozai" target="_blank" rel="noopener noreferrer" className="text-slate-400 hover:text-white transition-colors">
                                <IconGithub size={16} />
                            </a>
                        </div>
                    </div>

                    {/* 3D VIEWPORT */}
                    <div className="flex-1 relative bg-black">
                        <div ref={mountRef} className="w-full h-full cursor-move"></div>
                        
                        <div className="absolute top-4 left-4 pointer-events-none space-y-1 select-none">
                            <div className="flex items-center space-x-2">
                                <div className="w-3 h-3 rounded-full bg-yellow-400 shadow-[0_0_10px_rgba(250,204,21,0.5)]"></div>
                                <span className="text-xs text-yellow-100 font-mono">Inner Binary (M₁)</span>
                            </div>
                            <div className="flex items-center space-x-2">
                                <div className="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_rgba(239,68,68,0.5)]"></div>
                                <span className="text-xs text-red-200 font-mono">Perturber (M₃)</span>
                            </div>
                            <div className="flex items-center space-x-2">
                                <div className="w-8 h-0.5 bg-sky-400"></div>
                                <span className="text-xs text-sky-200 font-mono">Orbit Path</span>
                            </div>
                            <div className="flex items-center space-x-2">
                                <span className="text-2xl text-emerald-400 font-bold">↑</span>
                                <span className="text-xs text-emerald-200 font-mono">Angular Momentum</span>
                            </div>
                        </div>

                        <div className="absolute bottom-4 right-4 text-right pointer-events-none">
                            <h3 className="text-2xl font-black text-slate-800 select-none">3D VIEW</h3>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<KozaiApp />);
    </script>
</body>
</html>